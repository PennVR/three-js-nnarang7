<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Project1</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>

	<body>
		<script src="js/three.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/NoiseGenerator.js"></script>
		<script src="js/MaterialsGenerator.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/VRControls.js"></script>
		<script src="js/VREffects.js"></script>
		<script src="js/WebVR.js"></script>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>

		<script>
			if ( !Detector.webgl ) {
				Detector.addGetWebGLMessage();
				document.getElementById('container').innerHTML = "";
			}

			if ( WEBVR.isAvailable() === false ) {
				document.body.appendChild( WEBVR.getMessage() );
			}

			var camera, controls, scene, renderer;
			var mesh, texture;

			var all_fireworks = [];

			var firework_id = 0;

			var worldWidth = 256;
			var worldDepth = 256;

			var clock = new THREE.Clock();

			init();
			animate();


			function init() {
				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000);

				camera.position.x = 300;

				scene = new THREE.Scene();

				var plane = new THREE.PlaneBufferGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1);
				plane.rotateX( - Math.PI / 2 );

				var vertices = plane.attributes.position.array;
				var p_data = generateRandomArray(worldWidth);
				var heightMap = createHeightMap(worldWidth, worldDepth, p_data);

				camera.position.y = heightMap[ worldWidth / 2 + worldDepth / 2 * worldWidth ] * 8 + 100;

				for (var i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
					vertices[j + 1] = heightMap[i] * 8;
				};

				plane.attributes.position.array = vertices;

				// var mountain_texture = new THREE.TextureLoader().load("images/dark-mountain.jpg");
				// mountain_texture.wrapS = THREE.RepeatWrapping;
				// mountain_texture.wrapT = THREE.RepeatWrapping;
				// mountain_texture.repeat.set(2, 2);

//				var mountain_material = new THREE.MeshBasicMaterial( {map: mountain_texture});
				var mountain_material = new THREE.MeshBasicMaterial({color: 0xffffff});
				var mountain_mesh = new THREE.Mesh( plane, mountain_material );
				scene.add( mountain_mesh );

				var sky = new THREE.SphereGeometry(1000, 80, 80);
				var sky_material = new THREE.MeshBasicMaterial( {color: 0x000000});

				var star_geometry = new THREE.Geometry();
				var starMap = generateStars(1000);

				var star_material = new THREE.ParticleBasicMaterial({
					color: 0xffffff,
//					map: THREE.ImageUtils.loadTexture("images/particle.jpg"),
					size: 5
				});

				for (var i = 0; i < starMap.length; i += 3) {
					var v = new THREE.Vector3(starMap[i], starMap[i + 1], starMap[i + 2]);
					star_geometry.vertices.push(v);
				}

				var star_system = new THREE.ParticleSystem( star_geometry, star_material );

				scene.add( star_system );	

				var sky_mesh = new THREE.Mesh( sky, sky_material);
				sky_mesh.material.side = THREE.BackSide;
				scene.add( sky_mesh );

				var moon_geometry = new THREE.SphereGeometry(4, 50, 50);
				var moon_material = new THREE.MeshBasicMaterial({
					color: 0xfee5ac
				});
				var moon = new THREE.Mesh(moon_geometry, moon_material);
				moon.position.set(camera.position.x + 60, camera.position.y + 40, camera.position.z + 100);
				moon.material.side = THREE.BackSide;
				scene.add(moon);

				var moonlight = new THREE.PointLight(0xfee5ac, 10, 0, 2);
				moonlight.position.set(camera.position.x + 60, camera.position.y + 40, camera.position.z + 100);
				scene.add( moonlight );

				createFireworks(500);

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0x87cefa );
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);

				// controls = new THREE.OrbitControls(camera, renderer.domElement);
				// controls.addEventListener('change', animate);
				// controls.enableZoom = false;

				var container = document.getElementById("container");

				container.innerHTML = "";
				container.appendChild(renderer.domElement);


				if ( WEBVR.isAvailable() === true ) {
					document.body.appendChild( WEBVR.getButton( effect ) );
				}

				if (navigator.getVRDisplays) {
					controls = new THREE.VRControls( camera );
					var effect = new THREE.VREffect( renderer );
					navigator.getVRDisplays()
						.then((displays) => {
							effect.setVRDisplay(displays[0]);
							controls.setVRDisplay(displays[0]);
						})
						.catch(() => {});					
				}	

			}

			function animate() {
				if (navigator.getVRDisplays) {
					effect.requestAnimationFrame(animate);
				} else {
					requestAnimationFrame( animate );					
				}

				updateFireworks();					

//				controls.update();


				camera.rotation.y -= 0.005;				

				render();

//				camera.rotation.x -= 10;
//				camera.rotation.x += 0.001;
			}

			function render() {

				if (navigator.getVRDisplays) {
					effect.render(scene, camera);
				} else {
					renderer.render( scene, camera );
				}
			}

			function createFireworks(num) {
				for (var i = 0; i < num; i++) {
					if (shouldMakeFirework()) {
//						console.log("making firework");
						
						var x = Math.random() * 700 - 200;
						var y = Math.random() * 700 - 380;
						var z = Math.random() * 600 - 250;						

						// var x = THREE.Math.randInt(camera.position.x - 150, camera.position.x + 150);
						// var y = THREE.Math.randInt(camera.position.y - 50, camera.position.y + 50);
						// var z = THREE.Math.randInt(camera.position.z - 10, camera.position.z + 10);


						var start = new THREE.Vector3(x, 0, z);
						var end = new THREE.Vector3(x, y, z);

						var color = getRandomColor();

						var fireworks_geometry = new THREE.Geometry();

						fireworks_geometry.vertices.push(start);

						var fireworks_material = new THREE.PointsMaterial({
							size: 10,
							color: 0xff69b4
						});

						var fireworks = new THREE.Points( fireworks_geometry, fireworks_material );

						var firework_obj = {
							geometry: fireworks_geometry,
							material: fireworks_material,
							system: fireworks,
							dest: [end],
							name: "fireworks" + firework_id
						};

						fireworks.name = firework_obj.name;

						scene.add( fireworks );						

						firework_id++;

						all_fireworks.push(firework_obj);
					}
				}
			}

			function updateFireworks() {

				for (var i = all_fireworks.length - 1; i >= 0; i--) {
					var current_firework = all_fireworks[i];
					var all_points = current_firework.geometry.vertices;

					var to_remove = scene.getObjectByName(all_fireworks[i].name);

//					console.log(to_remove);

					scene.remove( to_remove );

					for (var j = 0; j < all_points.length; j++) {
						all_points[j].x += (all_fireworks[i].dest[j].x - all_points[j].x) / 3;
						all_points[j].y += (all_fireworks[i].dest[j].y - all_points[j].y) / 3;
						all_points[j].z += (all_fireworks[i].dest[j].z - all_points[j].z) / 3;
					}
					all_fireworks[i].geometry.vertices = all_points;
					all_fireworks[i].geometry.verticesNeedUpdate = true;

					all_fireworks[i].system = new THREE.Points( all_fireworks[i].geometry, all_fireworks[i].material);	

					if (all_points.length == 1) {
						if (all_points[0].x > all_fireworks[i].dest[0].x ||
							all_points[0].y > all_fireworks[i].dest[0].y ||
							all_points[0].z > all_fireworks[i].dest[0].z) {
								explode_firework(i);
// 								var to_remove_obj = scene.getObjectByName( all_fireworks[i].name );

// 								all_fireworks.splice(i, 1);
// //								console.log(to_remove_obj);
// 								scene.remove( to_remove_obj );	
						}
					} else {
						all_fireworks[i].material.opacity -= 0.05
						all_fireworks[i].material.colorsNeedUpdate = true;

						if (all_fireworks[i].material.opacity <= 0.0) {
//								console.log("removing1 " + all_fireworks[i].name);

								var to_remove_obj = scene.getObjectByName( all_fireworks[i].name );

								all_fireworks.splice(i, 1);
//								console.log(to_remove_obj);
								scene.remove( to_remove_obj );							
						//	remove_firework(i);
						}
					}


// //					console.log( all_fireworks.system );
//					scene.add( all_fireworks.system );
				}

				for (var j = 0; j < all_fireworks.length; j++) {
					all_fireworks[j].system.name = all_fireworks[j].name;
					scene.add( all_fireworks[j].system );
				}
			}

			function explode_firework(index) {	

				var to_explode = all_fireworks[index];
				var to_explore_pos = to_explode.dest[0];

				var to_explode_obj = scene.getObjectByName( to_explode.name );

				scene.remove( to_explode_obj );

				var new_geometry = new THREE.Geometry();

				var new_material = new THREE.PointsMaterial({
						size: 5,
						color: 0x39ff14					
				});

				var new_dest = [];

				for (var i = 0; i < 40; i++) {
					var particle_color = getRandomColor();
					var x = THREE.Math.randInt(to_explore_pos.x - 20, to_explore_pos.x + 20);
					var y = THREE.Math.randInt(to_explore_pos.y - 20, to_explore_pos.y + 20);
					var z = THREE.Math.randInt(to_explore_pos.z - 20, to_explore_pos.z + 20);

					var x_end = THREE.Math.randInt(to_explore_pos.x - 200, to_explore_pos.x + 200);
					var y_end = THREE.Math.randInt(to_explore_pos.y - 200, to_explore_pos.y + 200);
					var z_end = THREE.Math.randInt(to_explore_pos.z - 200, to_explore_pos.z + 200);

					var start = new THREE.Vector3(x, y, z);
					var end = new THREE.Vector3(x_end, y_end, z_end);	

					new_geometry.vertices.push(start);

					new_geometry.colors.push(0x39ff14);

					new_dest.push(end);
				}

				all_fireworks[index].geometry = new_geometry;
				all_fireworks[index].geometry.verticesNeedUpdate = true;
				all_fireworks[index].material = new_material;
				all_fireworks[index].system = new THREE.Points( new_geometry, new_material );
				all_fireworks[index].dest = new_dest;

				all_fireworks[index].system.name = all_fireworks[index].name;

				scene.add( all_fireworks[index].system );

			}

			function remove_firework(i) {
//				console.log("removing " + i);
				var to_remove = all_fireworks[i];
//				console.log(to_remove.name);
				var to_remove_obj = scene.getObjectByName( to_remove.name );
//				console.log(to_remove_obj);
				scene.remove( to_remove_obj );
				all_fireworks.splice(i, 1);
			}
		</script>

	</body>
</html>